# 排序

## 1.1 各种内部排序的比较

## 1.2 冒泡排序([Code](./BubbleSort.cpp))

原理：比较两个相邻的元素，将值大的元素交换至右端。

思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。

实例：
```
int arr[] = {6,3,1,9,2,4,8,7,5};

[i=0] 第一趟冒泡(循环条件j<len(arr)-i-1)
  [j=0] 3,6,1,9,2,4,8,7,5
  [j=1] 3,1,6,9,2,4,8,7,5
  [j=2] 3,1,6,9,2,4,8,7,5
  [j=3] 3,1,6,2,9,4,8,7,5
  [j=4] 3,1,6,2,4,9,8,7,5
  [j=5] 3,1,6,2,4,8,9,7,5
  [j=6] 3,1,6,2,4,8,7,9,5
  [j=7] 3,1,6,2,4,8,7,5,9

[i=1] 第二趟冒泡
  [j=0] 1,3,6,2,4,8,7,5,9
  [j=1] 1,3,6,2,4,8,7,5,9
  [j=2] 1,3,2,6,4,8,7,5,9
  [j=3] 1,3,2,4,6,8,7,5,9
  [j=4] 1,3,2,4,6,8,7,5,9
  [j=5] 1,3,2,4,6,7,8,5,9
  [j=6] 1,3,2,4,6,7,5,8,9

... (冒泡排序中)

[i=7] 
  [j=0] 1,2,3,4,5,6,7,8,9
```

## 1.3 快速排序([Code](./BubbleSort.cpp))
原理：快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

实例：
```
int arr[] = {6,3,1,9,2,4,8,7,5};

/**
*  初始化 i=0, j=len(arr)-1, key=arr[i]
*  part1: 第一轮快排
**/
[i=0 j=8] 第一趟快排初始状态(循环从后与key比，然后从前往后比，直至i=j)
  //从后往前找比key小的值为止
  [i=0 j=8] 6,3,1,9,2,4,8,7,5
         -> 5,3,1,9,2,4,8,7,6 //交换a[i]与a[j]
  //从前往后找比key大的数为止
  [i=1 j=8] 5,3,1,9,2,4,8,7,6
  [i=2 j=8] 5,3,1,9,2,4,8,7,6
  [i=3 j=8] 5,3,1,9,2,4,8,7,6
         -> 5,3,1,6,2,4,8,7,9 //交换a[i]与a[j]

  //从后往前找比key小的值为止
  [i=3 j=8] 5,3,1,6,2,4,8,7,9
  [i=3 j=7] 5,3,1,6,2,4,8,7,9
  [i=3 j=6] 5,3,1,6,2,4,8,7,9
  [i=3 j=5] 5,3,1,6,2,4,8,7,9
         -> 5,3,1,4,2,6,8,7,9 //交换a[i]与a[j]
  //从前往后找比key大的数为止 
  [i=3 j=5] 5,3,1,4,2,6,8,7,9
  [i=4 j=5] 5,3,1,4,2,6,8,7,9
  [i=5 j=5] 5,3,1,4,2,6,8,7,9
  
  //将上述的数组按照key分成2块，分别用于作快速排序(递归)
  quickSort(arr,left,i-1);
  quickSort(arr,i+1,right);


/**
*  初始化 i=left, j=right, key=arr[i]
*  part2.1: 第2轮左侧快排
**/
[i=0 j=4] 第一趟快排初始状态(循环从后与key比，然后从前往后比，直至i=j)
  //从后往前找比key小的值为止
  [i=0 j=4] 5,3,1,4,2,*,*,*,*
  [i=0 j=3] 5,3,1,4,2,*,*,*,*
  [i=0 j=2] 5,3,1,4,2,*,*,*,*
  [i=0 j=1] 5,3,1,4,2,*,*,*,*
  [i=0 j=0] 5,3,1,4,2,*,*,*,*

  //将上述的数组按照key分成2块，分别用于作快速排序(递归)
  quickSort(arr,left,i-1);
  quickSort(arr,i+1,right);

/**
*  初始化 i=left, j=right, key=arr[i]
*  part2.2: 第2轮右侧快排
**/
[i=6 j=8] 第一趟快排初始状态(循环从后与key比，然后从前往后比，直至i=j)
  //从后往前找比key小的值为止
  [i=6 j=8] *,*,*,*,*,*,8,7,9
  [i=6 j=7] *,*,*,*,*,*,8,7,9
         -> *,*,*,*,*,*,7,8,9 //交换a[i]与a[j]

  //从前往后找比key大的数为止 
  [i=6 j=7] *,*,*,*,*,*,7,8,9
  [i=7 j=7] *,*,*,*,*,*,7,8,9

  //将上述的数组按照key分成2块，分别用于作快速排序(递归)
  quickSort(arr,left,i-1);
  quickSort(arr,i+1,right);
  
```

## 1.4 插入排序

### 1.4.1 直接插入排序([Code](./InsertSort.cpp))
原理：通过将一个记录插入到已经排好的有序表中，从而得到一个新的、记录数增1的有序表，这个过程称为1趟排序。(通常默认0号位存哨兵元素，而且排序默认从2号位开始，因为0-1号位只有1个有效元素，视为已排序)

实例：
```
int arr[] = {0,6,3,1,9,2,4,8,7,5};

/**
*  初始化 i=2, j=i-1
*  part1: 第一轮插入排序
**/
// 1. 由 arr[i] < arr [i-1] 则成立
// 2. 设置arr[0] = arr[i]
// 3. 设置arr[i] = arr[i-1]
// 4. 令j=i-1,从arr[j]开始向前寻找; 若arr[j]>arr[0],则将arr[j]后移一位，并继续循环； 若arr[j]<=arr[0],则退出循环
[i=2 j=1] 3,6,6,1,9,2,4,8,7,5
   [ j=0] 3,6,6,1,9,2,4,8,7,5
          // 5. 设置arr[j+1] = arr[0],即完成一趟循环
          3,3,6,1,9,2,4,8,7,5
/**
*  初始化 i=3, j=i-1
*  part2: 第二轮插入排序
**/
[i=3 j=2] 1,3,6,6,9,2,4,8,7,5
   [ j=1] 1,3,3,6,9,2,4,8,7,5
   [ j=0] 1,3,3,6,9,2,4,8,7,5
          1,1,3,6,9,2,4,8,7,5

/**
*  初始化 i=4, j=i-1
*  part3: 第三轮插入排序不满足条件
**/

/**
*  初始化 i=5, j=i-1
*  part3: 第三轮插入排序不满足条件
**/
[i=5 j=4] 2,1,3,6,9,9,4,8,7,5
    [j=3] 2,1,3,6,6,9,4,8,7,5
    [j=2] 2,1,3,3,6,9,4,8,7,5
    [j=1] 2,1,3,3,6,9,4,8,7,5
          2,1,2,3,6,9,4,8,7,5
```

### 1.4.2 选择插入排序([Code](./InsertSort.cpp))
此方案和直接插入排序方案基本一致，只是在查找插入位时，用了折半查找，减少了关键字的比较次数，但并为减少元素的移动次数。

### 1.4.3 2-路插入排序([Code](./InsertSort.cpp))

### 1.4.4 希尔排序([Code](./ShellSort.cpp))

```
void SheelInsert(int* arr,int n,int dk){
    int i,j,temp;
    for(i=dk;i<n;i++)//分别向每组的有序区域插入
    {
        temp=arr[i];
        for(j=i-dk;(j>=i%dk)&&arr[j]>temp;j-=dk)//比较与记录后移同时进行
            arr[j+dk]=arr[j];
        if(j!=i-dk)
            arr[j+dk]=temp;//插入
    }
}
void ShellSort(int* arr,int length,int dk){
    for(int i=dk;i>0;i--)
        SheelInsert(arr,length,i);
}

实例：
n=10
int arr[] = {0,6,3,1,9,2,4,8,7,5};
[dk=5 i=5] {0,6,3,1,9,2,4,8,7,5}
           temp = 2
           [dk=5 j=0] {0,6,3,1,9,2,4,8,7,5}
[dk=5 i=6] {0,6,3,1,9,2,4,8,7,5}
           temp = 4
           [dk=5 j=1 ] {0,6,3,1,9,2,6,8,7,5}
           [dk=5 j=-4] {0,4,3,1,9,2,6,8,7,5}
[dk=5 i=7] {0,4,3,1,9,2,6,8,7,5}
           temp = 8
           [dk=5 j=2 ] {0,4,3,1,9,2,6,8,7,5}
           [dk=5 j=-3] {0,4,3,1,9,2,6,8,7,5}
```


## 1.5 选择排序
### 1.5.1 简单选择排序

简单选择排序的每一趟（如第i趟），在后面n-i+1个元素中选出最小，并与数组中的第i个元素进行互换；直到第n-1趟排序做完（而第n趟不需进行），即完成排序。

```
实例：
       6,3,2,9,1,4,8,7,5
[i=0] 从0-(n-1)下标的元素中选出最小的元素
       1,3,2,9,6,4,8,7,5
[i=1] 从1-(n-1)下标的元素中选出最小的元素
       1,2,3,9,6,4,8,7,5
[i=2] 从2-(n-1)下标的元素中选出最小的元素(此处最小元素坐标与i值相等，不需交换)
       1,2,3,9,6,4,8,7,5
...
       1,2,3,4,5,6,7,8,9
[i=7] 从2-(n-1)下标的元素中选出最小的元素(此处最小元素坐标与i值相等，不需交换)
       1,2,3,4,5,6,7,8,9
```

### 1.5.2 树形选择排序

### 1.5.3 堆排序

## 1.6 归并排序([Code](./MergeSort.cpp))

归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分而治之的一个非常典型的应用。首先它将序列拆分成子序列，然后将子序列合并，得到完全有序的子序列，接着再将子序列合并成一个有序序列，依次递归，最后得到1个完整的序列，被称为二路归并。

```
实例：
                          6,3,2,9,1,4,8,7,5
                                  |
                      ------------------------
                      |                      |
                  6,3,2,9                1,4,8,7,5
                     |                       |
             -----------------         -----------------         
             |               |         |               |
            6,3             2,9       1,4            8,7,5
             |               |         |               |
           ------          ------   -------        --------
           |    |          |    |   |     |        |      |
           6    3          2    9   1     4        8     7,5
           |    |          |    |   |     |        |      |
           |    |          |    |   |     |        |    -----
           |    |          |    |   |     |        |    |   |
           6    3          2    9   1     4        8    7   5  <--分解完毕，开始归并
           |    |          |    |   |     |        |    |   |
           ------          ------   -------        ------   5
             |               |         |              |     |
            3,6             2,9       1,4            7,8    5
             |               |         |              |     |
             -----------------         ----------------     |
                     |                         |            |
                  2,3,6,9                   1,4,7,8         5
                     |                         |            |
                     ---------------------------            |
                                  |                         |
                          1,2,3,4,6,7,8,9                   5
                                  |                         |
                                  ---------------------------
                                                |
                                         1,2,3,4,5,6,7,8,9        


```


## 1.7 基数排序
### 1.7.1 多关键字的排序

### 1.7.2 链式基数排序

